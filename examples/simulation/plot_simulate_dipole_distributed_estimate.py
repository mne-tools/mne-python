"""
=======================================================
Perform a distributed source estimation on dipole field
=======================================================

First simulate the evoked fields generated by a single dipolar source, then
calculate a distributed (MNE) estimate for the singular source "distribution".
This example illustrates the "cross-talk" between source space locations in the
final source estimate, when the true source does not lie in the source space
(free dipole). See also the example `plot_mne_crosstalk_function.py`.
"""
# Author: Christopher Bailey <bailey.cj@gmail.com>
#
# License: BSD (3-clause)

from os import path as op
import numpy as np

from mne import read_forward_solution, read_cov, pick_types_forward
from mne.io import read_info
from mne.forward import make_forward_dipole, convert_forward_solution
from mne.minimum_norm import make_inverse_operator, apply_inverse
from mne.transforms import read_trans, apply_trans
from mne.datasets import sample
from mne.dipole import Dipole
from mne.simulation import simulate_evoked

print(__doc__)

###############################################################################
# Load sensor information from real data
data_path = sample.data_path()
subjects_dir = op.join(data_path, 'subjects')

fwd_fname = op.join(data_path, 'MEG', 'sample',
                    'sample_audvis-meg-eeg-oct-6-fwd.fif')
ave_fname = op.join(data_path, 'MEG', 'sample', 'sample_audvis-ave.fif')
cov_fname = op.join(data_path, 'MEG', 'sample', 'sample_audvis-cov.fif')
bem_fname = op.join(subjects_dir, 'sample', 'bem',
                    'sample-5120-5120-5120-bem-sol.fif')
trans_fname = op.join(data_path, 'MEG', 'sample',
                      'sample_audvis_raw-trans.fif')

cov = read_cov(cov_fname)
snr = 3.
lambda2 = 1.0 / snr ** 2
info = read_info(ave_fname)
rng = np.random.RandomState(0)

###############################################################################
# Create a Dipole object with a single, fixed-orientation dipole with
# amplitude changing over time

onepos = np.array([-0.06114857,  0.00536119,  0.05957982])  # left AC
oneori = np.array([0.01041216, -0.75029594, -0.66102011])  # "Heschl's" ori

times = np.arange(50, dtype=np.float) / info['sfreq']
pos = np.tile(onepos, [len(times), 1])  # same position
amplitude = 50e-9 * np.sin(30. * times)
ori = np.tile(oneori, [len(times), 1])  # same orientation
gof = np.ones((len(times),))

dip = Dipole(times, pos, amplitude, ori, gof)

###############################################################################
# Generate noisy evoked data from dipole using BEM model
stc_dip, fwd_dip = make_forward_dipole(dip, bem_fname, info, trans_fname)
evoked = simulate_evoked(fwd_dip, stc_dip, info, cov, snr=20.0,
                         random_state=rng)

# Plot simulated field map
evoked.plot_topomap(times=0.050, ch_type='mag', outlines='skirt')

###############################################################################
# Create and apply MNE estimator (MEG chans only)
fwd = read_forward_solution(fwd_fname)
forward_meg = pick_types_forward(fwd, meg=True, eeg=False, exclude='bads')
convert_forward_solution(forward_meg, force_fixed=True,
                         surf_ori=True, copy=False)
evoked_meg = evoked.pick_types(meg=True, eeg=False)

inv_opr = make_inverse_operator(evoked_meg.info, forward_meg, cov,
                                fixed=True, depth=None)
stc_MNE = apply_inverse(evoked_meg, inv_opr, lambda2, "MNE",
                        pick_ori=None)

###############################################################################
# Calculate and plot fieldmap predicted/explained by MNE
evoked_MNE = simulate_evoked(forward_meg, stc_MNE, evoked_meg.info,
                             None, snr=np.inf)
evoked_MNE.plot_topomap(times=0.050, ch_type='mag', outlines='skirt')

###############################################################################
# Plot MNE on white matter surface, add the true position of the dipole
brain = stc_MNE.plot(hemi='lh', subject='sample', surface='white',
                     subjects_dir=subjects_dir)
brain.set_time(50)

head_mri_t = read_trans(trans_fname)
pos_mri = apply_trans(head_mri_t['trans'], dip.pos[0], move=True)
brain.add_foci(pos_mri*1000., color='springgreen')

# This requires a PR to PySurfer, basically an add_foci that calls
# quiver3d instead of points3d...
# ori_mri = apply_trans(head_mri_t['trans'], dip.ori[0], move=False)
# brain.add_arrows(pos_mri*1000., ori_mri, color='springgreen',
#                  mode='cone', scale_factor=1.)
