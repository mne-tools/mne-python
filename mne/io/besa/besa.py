from pathlib import Path
import numpy as np

from ...channels import read_custom_montage
from ...utils import logger, fill_doc, verbose
from ..meas_info import create_info
from ...evoked import EvokedArray


@fill_doc
@verbose
def read_evoked_besa(fname, head_size=0.095, verbose=None):
    """Reader function for BESA .avr or .mul files.

    When a .elp sidecar file is present, it will be used to determine electrode
    positions.

    Parameters
    ----------
    fname : str | Path
        Path to the .avr or .mul file.
    head_size : float | None
        Scale electrode positions to fit the given head radius (in meters). Set
        to ``None`` to keep the electrode positions as defined in the .elp
        file. Defaults to 0.095.
    %(verbose)s

    Returns
    -------
    ev : Evoked
        The evoked data in the .avr or .mul file.
    """
    fname = Path(fname)
    if fname.suffix == '.avr':
        return _read_evoked_besa_avr(fname, head_size, verbose)
    elif fname.suffix == '.mul':
        return _read_evoked_besa_mul(fname, head_size, verbose)
    else:
        raise ValueError('Filename must end in either .avr or .mul')
    

@verbose
def _read_evoked_besa_avr(fname, head_size=0.095, verbose=None):
    """Reader function for BESA .avr files."""
    with open(fname) as f:
        header = f.readline().strip()

        # There are two versions of .avr files. The old style, generated by
        # BESA 1, 2 and 3 does not define Nchan and does not have channel names
        # in the file. The channels info will have to be read from an .elp
        # sidecar file.
        new_style = 'Nchan=' in header
        if new_style:
            ch_names = f.readline().strip().split()

    fields = _parse_header(header)

    # Read in the data matrix
    data = np.loadtxt(fname, skiprows=2 if new_style else 1, ndmin=2)

    # See if there is an .elp sidecar file with electrode information.
    fname_elp = fname.parent / (fname.stem + '.elp')
    if fname_elp.exists():
        logger.info(f'Reading electrode names and positions from {fname_elp}')
        montage = read_custom_montage(fname_elp, head_size=head_size)
    else:
        montage = None

    # Consolidate information about the channels
    if new_style:
        if len(ch_names) != len(data):
            raise RuntimeError('Mismatch between the number of names defined '
                               f'on line 2 of the .avr file ({len(ch_names)}) '
                               'and the number of rows in the data matrix '
                               f'({len(data)}).')
    else:  # Old style
        if montage is None:
            # Old-style .avr files have no information about the electrodes!
            logger.info(f'No {fname_elp} file found, can not read electrode '
                        'information.')
            ch_names = [f'CH{i + 1:02d}' for i in range(len(data))]
        else:
            if len(montage.ch_names) != len(data):
                raise RuntimeError('Mismatch between the number of channels '
                                   f'defined in the .avr file ({len(data)}) '
                                   f'and .elp file ({len(montage.ch_names)}).')
            ch_names = montage.ch_names
        montage = None

    # Go over all the header fields and make sure they are all defined to
    # something sensible.
    if 'Npts' in fields and fields['Npts'] != data.shape[1]:
        logger.warn(f'The size of the data matrix ({data.shape}) does not '
                    f'match the "Npts" field ({fields["Npts"]}).')
    if 'DI' not in fields:
        raise RuntimeError('No "DI" field present. Could not determine '
                           'sampling frequency.')
    if 'TSB' not in fields:
        fields['TSB'] = 0
    if 'SB' not in fields:
        fields['SB'] = 1
    if 'SegmentName' not in fields:
        fields['SegmentName'] = ''

    # Build the Evoked object based on the header fields.
    info = create_info(ch_names, sfreq=1000 / fields['DI'], ch_types='eeg')
    ev = EvokedArray(data, info, tmin=fields['TSB'] / 1000,
                     comment=fields['SegmentName'], verbose=verbose)
    if montage:
        ev.set_montage(montage, verbose=verbose)
    return ev


@verbose
def _read_evoked_besa_mul(fname, head_pos=0.095, verbose=None):
    """Reader function for BESA .mul files."""
    pass


def _parse_header(header):
    """Parse an .avr or .mul header string into name/val pairs.

    The header line looks like:
        Npts= 256   TSB= 0.000 DI= 4.000000 SB= 1.000 SC= 200.0 Nchan= 27
    No consistent use of separation chars, so parsing this is a bit iffy.

    Parameters
    ----------
    header : str
        The first line of the file.

    Returns
    -------
    fields : dict
        The parsed header fields
    """
    parts = header.split()  # Splits on one or more spaces
    name_val_pairs = zip(parts[::2], parts[1::2])
    fields = dict((name.replace('=', ''), val) for name, val in name_val_pairs)

    # Attempt to convert string values to a proper numerical type.
    for name, val in fields.items():
        try:
            fields[name] = int(val)
        except ValueError:
            try:
                fields[name] = float(val)
            except ValueError:
                pass  # Keep as string value
    return fields
