from inspect import signature


def _pop_with_fallback(mapping, key, fallback_fun):
    """Pop from a dict and fallback to a function parameter's default value."""
    fallback = signature(fallback_fun).parameters[key].default
    return mapping.pop(key, fallback)


def _triage_old_psd_kwargs(*, arginfo=None, kwargs=None):
    """Convert .plot_psd(params) into .compute_psd(params).plot(other_params).

    Only one of ``arginfo`` or ``kwargs`` may be passed. ``arginfo`` should be
    a named tuple instance such as is generated by ``inspect.getargvalues``.
    ``kwargs`` should be a dict.

    Returns a tuple of dicts (one for ``inst.compute_psd()`` and one for
    ``[Epochs]Spectrum.plot()``.

    NOTE: using `plot_raw_psd` for fallback values for various params is OK
    because (1) the params have the same defaults in `plot_epochs_psd` and
    (2) they are both `@legacy` functions so their defaults won't change.
    """
    from ..io import BaseRaw
    from ..viz import plot_raw_psd as fallback_fun
    from ..time_frequency import Spectrum

    # make sure we got valid input
    msg = 'Must pass non-None values for either `arginfo` or `kwargs` '
    if arginfo is not None:
        assert kwargs is None, msg + '(but not both).'
        kwargs = {k: v for k, v in arginfo.locals.items() if k in arginfo.args}
        # add in **method_kw
        if arginfo.keywords is not None:
            kwargs.update(arginfo.locals[arginfo.keywords])
    else:
        assert kwargs is not None, msg + '(both were `None`).'

    # for compatibility with `plot_raw_psd` and `plot_epochs_psd`
    if 'raw' in kwargs:
        kwargs['self'] = kwargs.pop('raw')
    elif 'epochs' in kwargs:
        kwargs['self'] = kwargs.pop('epochs')

    # `reject_by_annotation` not needed for Epochs or Evoked
    if not isinstance(kwargs.pop('self', None), BaseRaw):
        kwargs.pop('reject_by_annotation', None)

    # handle API changes from .plot_psd(...) to .compute_psd(...).plot(...)
    kwargs['axes'] = _pop_with_fallback(kwargs, 'ax', fallback_fun)
    kwargs['alpha'] = _pop_with_fallback(kwargs, 'line_alpha', fallback_fun)
    kwargs['ci_alpha'] = _pop_with_fallback(kwargs, 'area_alpha', fallback_fun)
    est = _pop_with_fallback(kwargs, 'estimate', fallback_fun)
    kwargs['amplitude'] = 'auto' if est == 'auto' else (est == 'amplitude')
    area_mode = _pop_with_fallback(kwargs, 'area_mode', fallback_fun)
    kwargs['ci'] = 'sd' if area_mode == 'std' else area_mode

    # split off the plotting kwargs. user-defined picks should only be passed
    # to the Spectrum constructor (otherwise integer picks could be wrong,
    # `None` will be handled wrong for `misc` data, etc)
    plot_kwargs = {k: v for k, v in kwargs.items() if
                   k in signature(Spectrum.plot).parameters and k != 'picks'}
    for k in plot_kwargs:
        del kwargs[k]
    plot_kwargs['picks'] = 'all'

    # sanity check
    overlapping_kwargs = set(kwargs).intersection(set(plot_kwargs))
    if len(overlapping_kwargs):  # might be 0 for `mne.Reports`
        assert overlapping_kwargs == set(['picks'])

    return kwargs, plot_kwargs
